\section{Interazione Client/Server}
Essendo i protocolli TCP e UDP implementati direttamente dal SO, implementare le opportune funzioni per interagire con essi è l'unica cosa necessaria per permettere l'invio e la ricezione dei dati.
I SO mettono a disposizione delle API, insiemi di funzioni per facilitare l'utilizzo di questi protocolli agli sviluppatori.
I \textbf{socket} sono fondamentalmente delle Internet API.

Un socket è una \textit{porta} che collega un'applicazione con un protocollo di trasporto; in Python è rappresentato da una struttura dati.

\begin{lstlisting}
import socket
s = socket.socket(addr_family, type, protocol)
\end{lstlisting}

Gli argomenti della funzione socket() specificano le informazioni necessarie per la creazione di un nuovo socket.

\begin{itemize}
\item \textbf{addr\_family} : famiglia di protocolli, specificati come socket.NOME\_PROTOCOLLO.
\begin{itemize}
	 \item AF\_INET: IPv4 protocol
	 \item ADF\_INET6: IPv6 protocol
	 \item AF\_UNIX: per gestire comunicazioni tra processi sulla stessa macchina fisica.
\end{itemize}
\item \textbf{type}: specifica se il tipo di comunicazione è orientata allo stream o a pacchetto.
\begin{itemize}
	\item SOCK\_STREAM: stream-oriented
	\item SOCK\_DGRAM: message oriented
	\item SOCK\_RAW: fornisce accesso al network layer
\end{itemize}
\item protocol: se 0, il default è definito dalla coppia addr\_family+type.
\begin{lstlisting}
socket.AF_INET + socket.SOCK_STREAM = TCP
\end{lstlisting}
\end{itemize}

\subsection{TCP}

\begin{minipage}[t]{0.45\textwidth}

\subsubsection{Server-side.}
\paragraph{socket()}
\paragraph{bind(\textit{address})}
\textbf{address}: tupla (host,port) 
\textbf{host}: può essere un hostname nella notazione di domain internet o un indirizzo IPv4.
Si assicura che i pacchetti siano inoltrati al corretto destinatario.
host="" specifica tutte le interfacce network locali
host="localhost" specifica l'interfaccia di loopback\footnote{un'interfaccia network virtuale per gestire comunicazioni tra processi sullo stesso host. Bypassa l'hardware dell'interfaccia network locale e i livelli più bassi del protocol stack. 
% Manca una parte!
}

\textbf{port}: intero
Attenzione: port numbers non tutti utilizzabili! Spesso utilizzati da servizi standard.
generalmente quelli temporanei: 49152-65535
%Note su IANA
	
\paragraph{listen(backlog)}
Comunica al SO di iniziare ad ascoltare richieste di connessione su quel socket.Il \textit{backlog}specifica il numero massimo di connessioni accodate. Ovviamente, questo valore è sys-dependent. Su Linux si riferisce alle connessioni attive (default: 5) per motivi di sicurezza - SYN flood attacks. Se il backlog è pieno, nuove connessioni possono essere ignorate o rifiutate.

\paragraph{accept()}
Preleva e stabilisce una connessione dal backlog; crea un nuovo socket per essa.
Se non trova connessioni sul backlog si blocca.	
Perchè nuovo socket?
Mentre il primo socket creato è definito come \textit{socket passivo} e viene utilizzato solo per %...?
, quello creato dall'\textit{accept()} è un socket \textit{attivo}, con stesso socket name (quindi stesso indirizzo e port number), effettivamente collegato al socket del client, ed è quello utilizzato per scambiare dati.
La presenza di un numero di socket crescente fa sorgere il problema della distinzione di un socket dall'altro.
Per fare questo, ciò che rende un socket attivo unico è una quadrupla
\begin{lstlisting}
(local\_ip, local\_port, remote\_ip, remote\_port)
\end{lstlisting}
attraverso la quale il SO nomina e gestisce ogni singola connessione TCP.
	
\paragraph{recv(bufsize[,flags])}
	\textit{bufsize} è un intero che specifica il numero massimo di dati da ricevere in una volta
	\textit{data} è una stringa che rappresenta i dati ricevuti. In caso di assenza di dati, recv() si blocca e il programma è in pausa fino all'arrivo di dati.
		se ci sono dati, ..
%		davide
	Come capire se sono stati ricevuti tutti i dati?
\begin{lstlisting}
def recv_all(sock, len):
	data = ""
	while 1:
		read_data = sock.recv(length)
		if read_data == ``:
			break
		data += read_data
	return data
\end{lstlisting}
		PROBLEMA: in questo modo la comunicazione è unidirezionale, non posso inviare se ricevo.
		def recv\_all(sock, len):
			data = ""
			while len(data) < len:
				read\_data = sock.recv(len - len(data))
				if read\_data == ``:
					raise EOFError('socket closed.')
				data += read\_data
			return data
		altrimenti..
			quando il server legge l'header content\_length sa che quella è la lunghezza del messaggio!			
send()
recv()
close()
	chiude il socket.
	Tutte le operazioni future sull'oggetto falliranno.
	Attenzione: la connessione non è chiusa immediatamente. Il SO deve prima finire di inviare tutti i dati ancora presenti nel buffer.
	Alternativa:
		shutdown(how)
			Chiude uno dei due sensi di comunicazione. Non distrugge il socket.
			SHUT\_RD chiude il canale che va dal server al client
			SHUT\_WR chiude il canale dal client al server
			SHUT\_RDWR chiude entrambi i canali. Il socket è effettivamente 'chiuso', ma è diverso da close(): es, in multithread, la connessione TCP è chiusa solo quando l'ultimo thread da close(); con shutdown chiude tutto.

\end{minipage}
\begin{minipage}[t]{0.1\textwidth}\hfill
\end{minipage}
\begin{minipage}[t]{0.45\textwidth}
\subsubsection{client-side.}
\paragraph{socket()}
\paragraph{connect(address)} Si connette ad un socket remoto. Il SO assegna automaticamente un indirizzo e un numero di porta.\\
Argomenti: come server-side.
Se è utilizzato un socket TCP, comunica al SO di iniziare la \textit{3-way handshake}.
\paragraph{send()}
\paragraph{recv()}
\paragraph{close()}
\hfill

\begin{lstlisting}
sock = ...
sock.bind(...)
sock.listen(...)
while 1:
	sock\_cli, addr = sock.accept() \# accetta una nuova client connection
	...
	# gestione dell'invio e della ricezione di pacchetti
	numBytesSent= socket.send(string[,flags])
		# string: dati da inviare
		# nBS: numero di byte inviati
		# Attenzione: le applicazioni sono responsabili per il controllo dei dati inviati!
\end{lstlisting}


Dopo una send() TCP, ci sono tre possibilità:
	- dati possono essere subito accettati dal sistema
		la send() ritorna immediatamente, e ritorna la lunghezza della stringa
	- la network card è impegnata e il buffer interno del socket è pieno
		send() blocca 
%		davide

	while bytes\_sent < len(message):
		message\_remaining = message[bytes\_sent:]
		bytes\_sent+= sock.send(message\_remaining)

oppure....
	socket.sendal(string[,flags])
\end{minipage}

\subsection{UDP}

Per ricevere dati:
\begin{lstlisting}
import socket
string, address = socket.recvfrom(bufsize[,flags])
MAX = 65535
PORT=1060
sock.bind(('127.0.0.1', PORT)

while true:
	msg, address = socket.recv
	%...
\end{lstlisting}
Possiamo usare la funzione connect() con sockets UDP per evitare di specificare ogni volta l'indirizzo del server sul quale vogliamo chiamare una sendto(). In questo modo il client non prevede la ricezione di pacchetti da altri mittenti.\\
Attenzione: l'utilizzo di connect() non implica l'invio di dati.\\
\textbf{socket.settimeout(\textit{value})}\\
Problema: se la risposta è perduta?\\
Non vogliamo che il client resti bloccato per sempre, ma non è facile capire perchè il pacchetto non è arrivato.
%Possibili cause di perdita di pacchetti
Soluzione: usare un timeout. Se passano \#value secondi senza ricezione, il SO lancia una socket.timeout exception.