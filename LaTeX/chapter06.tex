\section{Informazioni generali}
La sicurezza informatica si fonda su diversi concetti:
\begin{itemize}
	\item \textbf{confidenzialità}: soltanto \textit{sender} e \textit{receiver} possono \textit{capire} il contenuto di un messaggio;
	\item \textbf{autenticazione}: soltanto \textit{sender} e \textit{receiver} possono confermare l'identità di ciascuno;
	\item \textbf{integrità di messaggio}: \textit{sender} e \textit{receiver} devono essere sicuri che il messaggio sia integro;
	\item \textbf{accesso e disponibilità}: i servizi devono essere accessibili e disponibili agli utenti.
\end{itemize}

\paragraph{Personaggi noti}
\textit{Bob} e \textit{Alice} vogliono comunicare in maniera sicura; \textit{Eve} è l'intruso, che vuole ottenere - senza permesso - le informazioni tra i due precedenti comunicanti, tramite \textit{eavesrop} (intercettazione), \textit{iniettazione} dei messaggi nella rete, \textit{personificazione} (pretendendo di essere qualcun altro); \textit{hijacking} (sostituendo uno dei capi della trasmissione con sé stesso), provocazione di \textit{denial of service} (prevenendo il servizio dall'essere usato dagli utenti, attraverso l'\textit{overload} delle risorse, per esempio).
\newpage

\section{Crittografia}
Il messaggio in chiaro si dice \textit{plain-text}; una volta crittografato, invece, \textit{cipher-text}. \\
Avendo soltanto il \textit{cipher-text} posso:
\begin{enumerate}
	\item fare \textit{brute-force}: tentare utilizzando tutte le chiavi in mio possesso per \textit{decriptare} il messaggio;
	\item utilizzare un'analisi statistica per risalire attraverso calcoli probabilistici a sequenze di caratteri noti (nel caso in cui si utilizzino metodi di cifrature \textit{monoalfabetici}).
\end{enumerate}

\subsection{Crittografia a chiave simmetrica}
Due o più persone condividono la stessa chiave (simmetrica), utilizzata come pattern ci cifratura a sostituzione mono alfabetica. Come si accordano, però, Bob e Alice? Occorre un sistema di scambio di chiavi attraverso un canale sicuro (anche fisico, per esempio).
\subsubsection{Schema di cifratura di Cesare}
Sistema di cifratura basato su uno spostamento/slittamento di \textit{n} lettere sulla sequenza dell'alfabeto. In questo caso, la chiave è proprio \textit{n}.

\subsubsection{DES: Data Encryption Standard}
Standard di criptazione, che utilizza chiavi lunghe \textit{56bit}, di cui si usano \textit{48bit}. Il messaggio viene spezzato in frammenti da 64bit, e passa per l'algoritmo blocco per blocco, tramite sistemi di permutazione. E' stato necessario nemmeno un giorno per \textit{bucarlo}. \\
Per questa ragione hanno sviluppato il \textit{3DES}, algoritmo di criptazione che prevede 3 passaggi: una \textit{encryption} iniziale utilizzando una chiave iniziale, una \textit{decription}, utilizzando una seconda chiave, e una \textit{encryption} finale, tramite la chiave iniziale.

\subsubsection{AES: Advanced Encryption Standard}
Standard molto più attuale. Utilizza un sistema di criptazione simmetrica che nel 2001 ha rimpiazzato \textit{DES}. Processa dati in blocchi da \textit{128bit}, con chiavi da \textit{128}/\textit{192}/\textit{256 bit}, per cui si dice abbia sicurezza di un ordine di $2^{128}$. \\
Mentre occorreva 1s per decriptare lo standard \textit{DES}, occorrono 149 trilioni di anni per farlo con \textit{AES}.
\newpage

\subsection{Modus operandi}
Il \textit{modus operandi} di un algoritmo di cifratura è il modo con cui vengono scambiati i blocchi, e prende il nome di \textit{ECB} (o \textit{Elecronic CodeBook}).
Altro metodo è quello del \textit{CBC} (o \textit{Cipher Block Chaining}), dove l'output del blocco precedente è l'input del blocco successivo.

\subsection{Crittrogafia a chiave pubblica}
Utilizza un approccio totalmente differente: il \textit{sender} e il \textit{receiver} hanno rispettivamente due chiavi: una privata e una pubblica. Non condividono la loro chiave privata, ma solo la pubblica, quindi la chiave di decriptazione privata è nota solo al \textit{receiver}. \\
Sostanzialmente, quando Alice vuole inviare un messaggio a Bob, lo cripta con la chiave pubblica di Bob, il quale - quando riceverà il messaggio criptato - lo decripterà con la propria chiave privata, e/o viceversa. \\
Tra gli algoritmi di crittografia a chiave pubblica più importanti troviamo l'\textit{RSA} (dai suoi creatori: \textit{Rivest}, \textit{Shamir} e \textit{Adelson}), che si basa sul fatto che bit può essere univocamente rappresentabile da un numero. Per creare un paio di chiavi \textit{RSA} occorre:
\begin{itemize}
	\item scegliere due numeri \textit{p} e \textit{q} (utilizzando, ad esempio, 1024 bit per ciascuno);
	\item si calcola $n=p\times q$ e $z=(p-1)\times (q-1)$;
	\item si sceglie una $e < n$ che non ha nulla in comune con \textit{z} (per cui si dicono \textit{relativamente primi});
	\item si sceglie una \textit{d} in modo tale che $(e\times d)-1$ sia divisibile per \textit{z}.
\end{itemize}
Infine:
\begin{center}
	Criptazione: $c = m^e$ $mod$ $n$ \\
	Decriptazione: $m = c^d$ $mod$ $n$
\end{center}

\section{Autenticazione}
\subsection{Firme digitali}
Una firma digitale rappresenta un insieme di dati in forma elettronica, allegati oppure connessi tramite associazione logica ad altri dati elettronici, utilizzati come metodo di identificazione informatica.

Si propone di soddisfare le seguenti esigenze:
\begin{itemize}
	\item \textbf{autenticazione:} il destinatario può verificare l'identità del mittente.
	\item \textbf{integrità:} il destinatario non può creare o modificare un documento firmato da qualcun altro.
	\item \textbf{non ripudio:} il mittente non può disconoscere un documento da lui firmato. La firma digitale è l'unico meccanismo basato su crittografia a chiave pubblica ad avere questa caratteristica.	
\end{itemize}

Un tipico schema di firma elettronica basato sulla tecnologia della chiave pubblica consiste di tre algoritmi:
\begin{enumerate}
	\item Un algoritmo che genera una coppia di chiavi $ (PK, SK) $, dove \textit{PK} è la chiave pubblica di verifica della firma e \textit{SK} è la chiave privata utilizzata per firmare il documento.
	\item Un algoritmo di firma che prende in input un messaggio \textit{m} e una chiave privata \textit{SK}, calcola il codice hash del messaggio e, crittografandolo con \textit{SK}, produce una firma $ \sigma $.
	\item un algoritmo di verifica che prende in input la tripla $(m, PK, \sigma)$ e accetta o rifiuta la firma.
\end{enumerate}
La firma digitale è l'unico caso in cui l'uso delle chiavi è invertito: la chiave pubblica serve a decrittare la firma e trovare poi il \textit{digest} iniziale attraverso l'hash, mentre la chiave privata serve a crittografare una stringa anzichè aprirla.

\subsection{Message digests}
Per dare una sorta di \textit{impronta digitale} di un'entità vengono utilizzati i cosiddetti \textbf{message digests}: partendo da un insieme enorme di combinazioni applicabili su ogni tipo di file digitale, una funzione di \textit{hashing} fa corrispondere un'entità a (quasi) una ed una sola sequenza di caratteri. In questo modo è possibile determinare una firma univoca per provare l'integrità di ogni file, potendo garantire che questa sia tale soltanto per quel file. La lunghezza dei valori di hash varia a seconda degli algoritmi utilizzati; il valore più comunemente adottato è di 128 bit, che offre una buona affidabilità in uno spazio relativamente ridotto\footnote{Va registrata la possibilità d'uso di hash di dimensione maggiore (SHA, ad esempio, può anche fornire stringhe di 224, 256, 384 e 512 bit) e minore (anche se fortemente sconsigliato).}. La sicurezza di questo sistema è data dal fatto che ogni \textit{hash} è dato da una stringa di lunghezza fissa indipendentemente dalla lunghezza del messaggio.\\
La firma digitale pul essere definita come \textit{digest} di un documento crittografato con chiave privata.


\subsubsection{Checksum}
La \textit{checksum} fa una sorta di \textit{hash} come è stato appena introdotto: produce una stringa da 16 bit. Il problema in questo caso riguarda il fatto che è molto più semplice trovare file diversi che abbiano lo stesso \textit{checksum}.\\\\
A questo punto possiamo arrivare alla combinazione ottimale: Bob manda un pacchetto di informazioni contenente:
\begin{itemize}
	\item messaggio puro;
	\item hash del messaggio, crittato con la chiave privata dello stesso Bob.
\end{itemize}
A questo punto, Alice, per verificare l'autenticità del messaggio, fa l'hash del messaggio e lo confronta con l'output della decrittazione tramite chiave pubblica di Bob dell'hash crittato precedentemente da Bob con la sua chiave privata. Se questi corrispondono, allora il messaggio risulta autentico.

Attualmente esistono diversi tipi di hash, in base al livello di sicurezza: leggermente datato è l'\textit{MD5} (da 128 bit, crittato in 4 passi), più aggiornato è invece lo \textit{SHA-1} (da 160 bit, ancora più sicuro è invece lo \textit{SHA-2}).

\subsection{CA (Certification Authority)}
La \textit{CA} rappresenta l'autorità che assegna un \textit{certificato digitale} (comprensivo dei dati di Bob con la sua firma digitale) ad una specifica entità E appartenente a Bob sulla base della chiave pubblica di E, in modo tale che sia garantita l'identità di E presso la \textit{CA}. Sostanzialmente, le informazioni del certificato digitale vengono prodotte dalla \textit{CA}, crittate con la chiave pubblica di Bob e poi con la chiave privata della \textit{CA}.
\newpage

\subsection{Sicurezza e-mail}
Alice vuole mandare una email confidenziale a Bob:
\begin{enumerate}
	\item genera una chiave privata simmetrica randomica, $K_{s}$;
	\item critta il messaggio con questa chiave $K_{s}$;
	\item critta l'output con la chiave pubblica di Bob;
	\item invia l'output e la chiave generata randomicamente a Bob, crittata ancora con la chiave pubblica di Bob.
\end{enumerate}
Bob, quindi, quando riceve la email, decritterà il messaggio e la chiave segreta generata randomicamente da Alice con la sua chiave privata e - ancora - decritterà il messaggio in definitiva utilizzando la chiave-output della decrittazione della chiave segreta generata randomicamente da Alice. \\
In alternativa:
\begin{enumerate}
	\item Alice fa un \textit{hash} del messaggio;
	\item impacchetta il messaggio in chiaro e la firma digitale (come già visto con i message digests);
	\item il pacchetto viene crittato con una chiave privata simmetrica randomica, $K_{s}$;
	\item viene mandato il pacchetto e la chiave generata randomicamente a Bob, crittata ancora con la chiave pubblica di Bob.
\end{enumerate}
Bob, quindi, quando riceve la email, decritterà il messaggio e la chiave segreta generata randomicamente da Alice con la sua chiave privata e - ancora - decritterà il messaggio in definitiva utilizzando la chiave-output della decrittazione della chiave segreta generata randomicamente da Alice. Bob, per verificare l'autenticità del messaggio, fa l'hash del messaggio e lo confronta con l'output della decrittazione tramite chiave pubblica di Alice dell'hash crittato precedentemente da Alice con la sua chiave privata. Se questi corrispondono, allora il messaggio risulta autentico.

\section{Secure Socket Layer}
Con l'apertura della Rete a fini pubblici, le problematiche di prevenzione di danni, perdite e attacchi via via sempre più importanti portarono alla nascita di strati aggiuntivi con lo specifico compito di assicurarsi la delle comunicazioni.
Le prime implementazioni di SSL erano limitate a una cifratura a chiave simmetrica di soli 40 bit\footnote{Tale limitazione fu dovuta da restrizioni imposte dal governo statunitense sull'esportazione di tecnologie crittografiche. Fu esplicitamente imposta per rendere la cifratura abbastanza debole da poter essere forzata dalle autorità giudiziarie che volessero decifrare il traffico, ma sufficientemente resistente ad attacchi esterni poichè facente affidamento alle minori disponibilità di risorse tecnologiche e finanziarie dell'epoca.}; fu succesivamente aggiornato a TLS (\textit{Transport Layer Security}), con chiavi da 128+ bit.\\\\
Il protocollo TLS consente alle applicazioni client/server di comunicare attraverso una rete in modo tale da prevenire il \textit{tampering}(manomissione), la falsificazione e l'intecettazione dei dati.\\
Nell'utilizzo tipico del browser di un end-user, l'autenticazione è \textit{unilaterale}: è il solo server ad autenticarsi presso il client. Il browser valida il certificato del server controllando che la firma digitale dei certificati sia valida e riconosciuta da una \textbf{certificate authority}\footnote{} conosciuta utilizzando una cifratura a chiave pubblica. Dopo questa autenticazione, il browser indica una connessione sicura.\\
Quest'autenticazione, però, non è sufficiente per garantire che il sito con cui ci si è collegati sia quello richiesto. Per esserne sicuri è necessario analizzare il contenuto del certificato rilasciato e controllarne la catena di certificazione. I siti che intendono ingannare l'utente non possono utilizzare un certificato del sito che vogliono impersonare, perchè non hanno la possibilità di cifrare in modo valido il certificato, 
che include l'indirizzo, in modo tale che risulti valido alla destinazione.\\
Il protocollo TLS permette anche un'autenticazione \textit{bilaterale}, tipicamente utilizzata in applicazioni aziendali, in cui entrambe le parti si autenticano in modo sicuro scambiandosi i relativi certificati. Questa autenticazione (definita \textit\textit{Mutual authentication}), richiede che anche il client possieda un proprio certificato digitale.\\

\subsection{Principi di funzionamento}
Il funzionamento del protocollo TLS può essere suddiviso in tre fasi principali:
\begin{enumerate}
	\item Negoziazione dell'algoritmo da utilizzare;
	\item Scambio delle chiavi e autenticazione;
	\item Cifratura simmetrica e autenticazione dei messaggi.
\end{enumerate}
Nella prima fase, il client e il server negoziano il protocollo di cifratura che sarà utilizzato nella comunicazione sicura, il protocollo per lo scambio delle chiavi, il MAC (\textit{message authentication code}) e l'algoritmo di autenticazione. L'algoritmo per lo scambio delle chiavi e quello per l'autenticazione normalmente sono a chiave pubblica; l'integrità dei messaggi è garantita da un algoritmo di hash che utilizza funzioni pseudorandom non standard.

\paragraph{Protocolli.} All'interno di una sessione vengono tipicamente utilizzati i seguenti protocolli:
\begin{itemize}
	\item RSA, Diffie-Hellman, ECDH, SRP, PSK per lo scambio di chiavi;
	\item RSA, DSA, ECDSA per l'autenticazione;
	\item RC4, DES, 3DES, AES, IDEA o Camellia (anche RC2 nei vecchi SSL) per la cifratura simmetrica;
	\item HMAC-MD5, HMAC-SHA (TLS); MD5, SHA (SSL) come funzioni di hash per le funzioni crittografiche d'integrità. 
\end{itemize}

\paragraph{ARP}
Una richiesta \textit{ARP} consiste in una richiesta di risoluzione inversa: invece di chiedere la risoluzione di un nome host, richiediamo la risoluzione inversa, ovvero quella che associa univocamente un IP ad un nome host. Il protocollo \textit{ARP} lavora a livello \textit{datalink} della pila \textit{TCP/IP}, quindi utilizzando come nomi identificativi gli indirizzi \textit{MAC}. Per la richiesta viene richiamato il gateway dell'IP richiesto, il quale fa una richiesta in \textit{broadcast} nella subnet per cercare il dato IP. \\
In un attacco \textit{arp-spoofing} (o \textit{arp-poisoning}), l'attaccante fa un attacco \textit{man-in-the-middle}, \textit{spacciandosi} per l'IP richiesto.